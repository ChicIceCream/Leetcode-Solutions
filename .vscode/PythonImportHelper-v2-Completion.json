[
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "ceil",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "Fraction",
        "importPath": "fractions",
        "description": "fractions",
        "isExtraImport": true,
        "detail": "fractions",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Contest Problems.1657 - Determine if Two Strings Are Close",
        "description": "Contest Problems.1657 - Determine if Two Strings Are Close",
        "peekOfCode": "class Solution:\n    def closeStrings(self, word1: str, word2: str) -> bool:\n        set1 = Counter(word1)\n        set2 = Counter(word2)\n        if set1.keys() != set2.keys():\n            return False \n        return sorted(list(set1.values())) == sorted(list(set2.values()))",
        "detail": "Contest Problems.1657 - Determine if Two Strings Are Close",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Contest Problems.2942 - Find Words Containing Character",
        "description": "Contest Problems.2942 - Find Words Containing Character",
        "peekOfCode": "class Solution:\n    def findWordsContaining(self, words: List[str], x: str) -> List[int]:\n        result = []\n        for index, word in enumerate(words):\n            if x in word:\n                result.append(index)\n        return result",
        "detail": "Contest Problems.2942 - Find Words Containing Character",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Contest Problems.3005 - Count Elements With Maximum Frequency",
        "description": "Contest Problems.3005 - Count Elements With Maximum Frequency",
        "peekOfCode": "class Solution:\n    def maxFrequencyElements(self, nums: List[int]) -> int:\n        count = Counter(nums)\n        # Find the maximum frequency\n        max_freq = max(count.values())\n        # Count the number of elements with maximum frequency\n        total_max_freq_elements = sum(freq for freq in count.values() if freq == max_freq)\n        return total_max_freq_elements",
        "detail": "Contest Problems.3005 - Count Elements With Maximum Frequency",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Contest Problems.74 - Search a 2D Matrix",
        "description": "Contest Problems.74 - Search a 2D Matrix",
        "peekOfCode": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        top, bot = 0, ROWS - 1\n        while top <= bot:\n            row = (top + bot) // 2\n            if target > matrix[row][-1]:\n                top = row + 1\n            elif target < matrix[row][0]:\n                bot = row - 1",
        "detail": "Contest Problems.74 - Search a 2D Matrix",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Contest Problems.Find the Power of K-Size Subarrays I",
        "description": "Contest Problems.Find the Power of K-Size Subarrays I",
        "peekOfCode": "class Solution:\n    def resultsArray(self, nums: List[int], k: int) -> List[int]: #type:ignore\n        results = []\n        for i in range(len(nums) - k + 1):\n            subarray = nums[i:i + k]\n            if subarray == sorted(subarray):\n                if all(subarray[j] + 1 == subarray[j + 1] for j in range(k - 1)):\n                    results.append(max(subarray)) # to get the max\n                else:\n                    results.append(-1)",
        "detail": "Contest Problems.Find the Power of K-Size Subarrays I",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Contest Problems.Snake In Matrix",
        "description": "Contest Problems.Snake In Matrix",
        "peekOfCode": "class Solution:\n    def finalPositionOfSnake(self, n: int, commands: List[str]) -> int: #type:ignore\n        answer = 0\n        for command in commands:\n            if command == \"UP\":\n                answer -= n\n            elif command == \"DOWN\":\n                answer += n\n            elif command == \"RIGHT\":\n                answer += 1",
        "detail": "Contest Problems.Snake In Matrix",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.1 - Two Sum",
        "description": "Normal Problems.1 - Two Sum",
        "peekOfCode": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]: #type:ignore\n        hashmap = {}\n        for x in range(len(nums)):\n            # x is the first number and y is the second number\n            y = target - nums[x]\n            if y in hashmap:\n                return [x, hashmap[y]]\n            hashmap[nums[x]] = x",
        "detail": "Normal Problems.1 - Two Sum",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.1021 - Remove Outermost Parentheses",
        "description": "Normal Problems.1021 - Remove Outermost Parentheses",
        "peekOfCode": "class Solution:\n    def removeOuterParentheses(self, s: str) -> str:\n        result = []\n        open_count = 0\n        for char in s:\n            if char == '(':\n                if open_count > 0:  # If this is not the outermost '(', add it to the result\n                    result.append(char)\n                open_count += 1\n            elif char == ')':",
        "detail": "Normal Problems.1021 - Remove Outermost Parentheses",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "Normal Problems.1026 - Maximum Difference Between Node and Ancestor",
        "description": "Normal Problems.1026 - Maximum Difference Between Node and Ancestor",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:\n        def dfs(node, min_val, max_val):\n            nonlocal max_diff\n            if not node:",
        "detail": "Normal Problems.1026 - Maximum Difference Between Node and Ancestor",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.1026 - Maximum Difference Between Node and Ancestor",
        "description": "Normal Problems.1026 - Maximum Difference Between Node and Ancestor",
        "peekOfCode": "class Solution:\n    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:\n        def dfs(node, min_val, max_val):\n            nonlocal max_diff\n            if not node:\n                return\n            # Update the maximum difference if found\n            max_diff = max(max_diff, abs(node.val - min_val), abs(node.val - max_val))\n            # Update the min and max values for the children\n            min_val = min(min_val, node.val)",
        "detail": "Normal Problems.1026 - Maximum Difference Between Node and Ancestor",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.1047 - Remove All Adjacent Duplicates In String",
        "description": "Normal Problems.1047 - Remove All Adjacent Duplicates In String",
        "peekOfCode": "class Solution:\n    def removeDuplicates(self, s: str) -> str:\n        stack = []\n        for char in s:\n            if stack:\n                if char == stack[-1]:\n                    stack.pop()\n                else:\n                    stack.append(char)\n            else:",
        "detail": "Normal Problems.1047 - Remove All Adjacent Duplicates In String",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.1207 - Unique Number of Occurrences",
        "description": "Normal Problems.1207 - Unique Number of Occurrences",
        "peekOfCode": "class Solution:\n    def uniqueOccurrences(self, arr: List[int]) -> bool:\n        occurrences = defaultdict(int)\n        for num in arr:\n            occurrences[num] += 1\n        return len(set(occurrences.values())) == len(occurrences)",
        "detail": "Normal Problems.1207 - Unique Number of Occurrences",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.121 - Best Time to Buy and Sell Stock",
        "description": "Normal Problems.121 - Best Time to Buy and Sell Stock",
        "peekOfCode": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int: # type: ignore\n        buy, sell = 0, 1\n        max_profit = 0\n        # repeat until the sell pointer reaches the end\n        while sell < len(prices):\n            # checking profit when sell is greater than buy\n            if prices[sell] > prices[buy]:\n                #calculates the profit\n                profit = prices[sell] - prices[buy]",
        "detail": "Normal Problems.121 - Best Time to Buy and Sell Stock",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.1235 - Maximum Profit in Job Scheduling",
        "description": "Normal Problems.1235 - Maximum Profit in Job Scheduling",
        "peekOfCode": "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        jobs = sorted(zip(startTime, endTime, profit), key=lambda x: x[1])\n        max_profit = [0] * len(jobs)\n        for i in range(len(jobs)):\n            prev_non_overlapping = self.binary_search(jobs, i)\n            current_profit = jobs[i][2] + (max_profit[prev_non_overlapping] if prev_non_overlapping != -1 else 0)\n            max_profit[i] = max(current_profit, max_profit[i - 1] if i > 0 else 0)\n        return max_profit[-1]\n    def binary_search(self, jobs, current_index):",
        "detail": "Normal Problems.1235 - Maximum Profit in Job Scheduling",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.125 - Valid Palindrome",
        "description": "Normal Problems.125 - Valid Palindrome",
        "peekOfCode": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        if s == \"\":\n            return False\n        checking = \"\"\n        for char in s:\n            if char.isalnum():\n                checking += char.lower()\n        print(f\"s : {s} and checking : {checking}\")\n        return checking == checking[::-1]",
        "detail": "Normal Problems.125 - Valid Palindrome",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.125 - Valid Palindrome",
        "description": "Normal Problems.125 - Valid Palindrome",
        "peekOfCode": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        left, right = 0, len(s) - 1\n        while left < right:\n            while left < right and not self.alphaNum(s[left]):\n                left += 1\n            while right > left and not self.alphaNum(s[right]):\n                right -= 1\n            if s[left].lower() != s[right].lower():\n                return False",
        "detail": "Normal Problems.125 - Valid Palindrome",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.1347 - Minimum Number of Steps to Make Two Strings Anagram",
        "description": "Normal Problems.1347 - Minimum Number of Steps to Make Two Strings Anagram",
        "peekOfCode": "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        s_counter = Counter(s)\n        t_counter = Counter(t)\n        diff = s_counter - t_counter\n        return sum(diff.values())",
        "detail": "Normal Problems.1347 - Minimum Number of Steps to Make Two Strings Anagram",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.145 - Binary Tree Postorder Traversal",
        "description": "Normal Problems.145 - Binary Tree Postorder Traversal",
        "peekOfCode": "class Solution:\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]: # type: ignore\n        if not root:\n            return []\n        stack = [root]\n        result = []\n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            if node.left:",
        "detail": "Normal Problems.145 - Binary Tree Postorder Traversal",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.1455 - Check If a Word Occurs As a Prefix of Any Word in a Sentence",
        "description": "Normal Problems.1455 - Check If a Word Occurs As a Prefix of Any Word in a Sentence",
        "peekOfCode": "class Solution:\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\n        # split up the words so only words print, without this part, it will give every letter instead\n        word_list = list(sentence.split())\n        # print(word_list)\n        for i in range(len(word_list)):\n            # print(i, word_list[i])\n            # to search through only the prefix part\n            searchWordLength = len(searchWord)\n            if searchWord in word_list[i][:searchWordLength]:",
        "detail": "Normal Problems.1455 - Check If a Word Occurs As a Prefix of Any Word in a Sentence",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.1475 - Final Prices With a Special Discount in a Shop",
        "description": "Normal Problems.1475 - Final Prices With a Special Discount in a Shop",
        "peekOfCode": "class Solution:\n    def finalPrices(self, prices: List[int]) -> List[int]:\n        stack = []\n        answer = prices[:]  # Start with a copy of prices as the answer list\n        for i in range(len(prices)):\n            # Apply the discount from the first lower or equal price to the right\n            while stack and prices[stack[-1]] >= prices[i]:\n                index = stack.pop()\n                answer[index] -= prices[i]\n            stack.append(i)",
        "detail": "Normal Problems.1475 - Final Prices With a Special Discount in a Shop",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.1482 - Minimum Number of Days to Make m Bouquets",
        "description": "Normal Problems.1482 - Minimum Number of Days to Make m Bouquets",
        "peekOfCode": "class Solution:\n    def get_num_of_bouquets(self, bloomDay, mid, k):\n        num_of_bouquets = 0\n        count = 0\n        for day in bloomDay:\n            # If the flower is bloomed, add to the set. Else reset the count.\n            if day <= mid:\n                count += 1\n            else:\n                count = 0",
        "detail": "Normal Problems.1482 - Minimum Number of Days to Make m Bouquets",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.150 - Evaluate Reverse Polish Notation",
        "description": "Normal Problems.150 - Evaluate Reverse Polish Notation",
        "peekOfCode": "class Solution:\n    def evalRPN(self, tokens: List[str]) -> int: # type: ignore\n        stack = []    \n        for char in tokens:\n            if char == '+' or char == '-' or char =='*' or char == '/':\n                if stack:\n                    a = int(stack.pop())\n                    b = int(stack.pop())\n                    if char == '+':\n                        stack.append(a + b)",
        "detail": "Normal Problems.150 - Evaluate Reverse Polish Notation",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.151 - Reverse Words in a String",
        "description": "Normal Problems.151 - Reverse Words in a String",
        "peekOfCode": "class Solution:\n    def reverseWords(self, s: str) -> str:\n        array = s.split()\n        return \" \".join(array[::-1])",
        "detail": "Normal Problems.151 - Reverse Words in a String",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.153 - Find Minimum in Rotated Sorted Array",
        "description": "Normal Problems.153 - Find Minimum in Rotated Sorted Array",
        "peekOfCode": "class Solution:\n    def findMin(self, nums: List[int]) -> int: # type: ignore\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        return nums[left]",
        "detail": "Normal Problems.153 - Find Minimum in Rotated Sorted Array",
        "documentation": {}
    },
    {
        "label": "MinStack",
        "kind": 6,
        "importPath": "Normal Problems.155 - Min Stack",
        "description": "Normal Problems.155 - Min Stack",
        "peekOfCode": "class MinStack:\n    def __init__(self):\n        self.stack = []\n        self.minStack = []\n    def push(self, val: int) -> None:\n        self.stack.append(val)\n        val = min(val, self.minStack[-1] if self.minStack else val)\n        self.minStack.append(val)\n    def pop(self) -> None:\n        self.stack.pop()",
        "detail": "Normal Problems.155 - Min Stack",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.162 - Find Peak Element",
        "description": "Normal Problems.162 - Find Peak Element",
        "peekOfCode": "class Solution:\n    from typing import List\n    def findPeakElement(self, nums: List[int]) -> int:\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            # Check if mid is a peak element by comparing with its neighbors\n            if (mid == 0 or nums[mid] > nums[mid - 1]) and (mid == len(nums) - 1 or nums[mid] > nums[mid + 1]):\n                return mid\n            # If the element at mid is less than the next element, the peak is in the right half",
        "detail": "Normal Problems.162 - Find Peak Element",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.1657 - Determine if Two Strings Are Close",
        "description": "Normal Problems.1657 - Determine if Two Strings Are Close",
        "peekOfCode": "class Solution:\n    def closeStrings(self, word1: str, word2: str) -> bool:\n        set1 = Counter(word1)\n        set2 = Counter(word2)\n        if set1.keys() != set2.keys():\n            return False \n        return sorted(list(set1.values())) == sorted(list(set2.values()))",
        "detail": "Normal Problems.1657 - Determine if Two Strings Are Close",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.1664 - Ways to Make a Fair Array",
        "description": "Normal Problems.1664 - Ways to Make a Fair Array",
        "peekOfCode": "class Solution:\n    def waysToMakeFair(self, nums: List[int]) -> int: #type:ignore\n        total_even = sum(nums[::2])  # Total sum of elements at even indices\n        total_odd = sum(nums[1::2])  # Total sum of elements at odd indices\n        prefix_even = prefix_odd = 0  # Initialize prefix sums for even and odd indices\n        count = 0  # Counter for fair indices\n        for i, num in enumerate(nums):\n            if i % 2 == 0:\n                total_even -= num  # Adjust even sum for removed element\n            else:",
        "detail": "Normal Problems.1664 - Ways to Make a Fair Array",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.167 - Two Sum II - Input Array Is Sorted",
        "description": "Normal Problems.167 - Two Sum II - Input Array Is Sorted",
        "peekOfCode": "class Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]: #type:ignore\n        left, right = 0, len(numbers) - 1\n        while left < right:\n            if numbers[left] + numbers[right] > target:\n                right -= 1\n            elif numbers[left] + numbers[right] < target:\n                left += 1\n            else: \n                return [left + 1, right + 1]",
        "detail": "Normal Problems.167 - Two Sum II - Input Array Is Sorted",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.1704 - Determine if String Halves Are Alike",
        "description": "Normal Problems.1704 - Determine if String Halves Are Alike",
        "peekOfCode": "class Solution:\n    def halvesAreAlike(self, s: str) -> bool:\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        vowels_dict = defaultdict(int)\n        for vowel in vowels:\n            vowels_dict[vowel] = 0\n        def count_vowels(string):\n            return sum(1 for char in string if char in vowels)\n        length = len(s)\n        mid = length // 2",
        "detail": "Normal Problems.1704 - Determine if String Halves Are Alike",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.1769 - Minimum Number of Operations to Move All Balls to Each Box",
        "description": "Normal Problems.1769 - Minimum Number of Operations to Move All Balls to Each Box",
        "peekOfCode": "class Solution:\n    def minOperations(self, boxes: str) -> List[int]:\n        answer = []\n        n = len(boxes)\n        for i in range(n):\n            moves = 0\n            for j in range(n):\n                if boxes[j] == '1':  \n                    moves += abs(i - j)  \n            answer.append(moves)",
        "detail": "Normal Problems.1769 - Minimum Number of Operations to Move All Balls to Each Box",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.1790 - Check if One String Swap Can Make Strings Equal",
        "description": "Normal Problems.1790 - Check if One String Swap Can Make Strings Equal",
        "peekOfCode": "class Solution:\n    def areAlmostEqual(self, s1: str, s2: str) -> bool:\n        hash1 = defaultdict(int)\n        hash2 = defaultdict(int)\n        for i in s1:\n            hash1[i] += 1\n        for i in s2:\n            hash2[i] += 1\n        if hash1 != hash2:\n            return False",
        "detail": "Normal Problems.1790 - Check if One String Swap Can Make Strings Equal",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.1800 - Maximum Ascending Subarray Sum",
        "description": "Normal Problems.1800 - Maximum Ascending Subarray Sum",
        "peekOfCode": "class Solution:\n    def maxAscendingSum(self, nums: List[int]) -> int: #type:ignore\n        cur_streak = maxi = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i - 1]:\n                cur_streak += nums[i]\n            else:\n                cur_streak = nums[i]\n            maxi = max(maxi, cur_streak)\n        return maxi",
        "detail": "Normal Problems.1800 - Maximum Ascending Subarray Sum",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.1897 - Redistribute Characters to Make All Strings Equal",
        "description": "Normal Problems.1897 - Redistribute Characters to Make All Strings Equal",
        "peekOfCode": "class Solution:\n    def makeEqual(self, words: List[str]) -> bool:\n        # make a distionary to store all the values\n        counts = defaultdict(int)\n        # iterate through the words\n        for word in words:\n            #then the letters\n            for c in word:\n                counts[c] += 1\n        n = len(words)",
        "detail": "Normal Problems.1897 - Redistribute Characters to Make All Strings Equal",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.1945 -Sum of Digits of String After Convert",
        "description": "Normal Problems.1945 -Sum of Digits of String After Convert",
        "peekOfCode": "class Solution:\n    def getLucky(self, s: str, k: int) -> int:\n        # Convert each character to its numerical value and build a string\n        numeric_string = \"\"\n        for ch in s:\n            numeric_string += str(ord(ch) - ord(\"a\") + 1)\n        # Apply digit sum transformations k times\n        for _ in range(k):\n            digit_sum = 0\n            for digit in numeric_string:",
        "detail": "Normal Problems.1945 -Sum of Digits of String After Convert",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.1961 - Check If String Is a Prefix of Array",
        "description": "Normal Problems.1961 - Check If String Is a Prefix of Array",
        "peekOfCode": "class Solution:\n    def isPrefixString(self, s: str, words: List[str]) -> bool: #type:ignore\n        prefix = \"\"  # Initialize an empty string to build the prefix\n        for word in words:\n            prefix += word  # Concatenate the current word to the prefix\n            if prefix == s:  # Check if the prefix matches `s`\n                return True\n            elif len(prefix) > len(s):  # Stop early if the prefix exceeds `s`\n                return False\n        return False  # If the loop ends and no match is found",
        "detail": "Normal Problems.1961 - Check If String Is a Prefix of Array",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.20 - Valid Parentheses",
        "description": "Normal Problems.20 - Valid Parentheses",
        "peekOfCode": "class Solution:\n    def isValid(self, s: str) -> bool:\n        if len(s) == 0:\n            return True\n        stack = []\n        bracket_mapping = {')': '(', ']': '[', '}': '{'}\n        for char in s:\n            if char in bracket_mapping:\n                if stack and stack[-1] == bracket_mapping[char]:\n                    stack.pop()",
        "detail": "Normal Problems.20 - Valid Parentheses",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.202 - Happy Number",
        "description": "Normal Problems.202 - Happy Number",
        "peekOfCode": "class Solution:\n    def isHappy(self, n: int) -> bool:    \n        def get_next_number(n):    \n            output = 0\n            while n:\n                digit = n % 10\n                output += digit ** 2\n                n = n // 10\n            return output\n        slow = get_next_number(n)",
        "detail": "Normal Problems.202 - Happy Number",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.2109 - Adding Spaces to a String",
        "description": "Normal Problems.2109 - Adding Spaces to a String",
        "peekOfCode": "class Solution:\n    def addSpaces(self, s: str, spaces: List[int]) -> str: #type:ignore\n        final_list = []\n        prev_index = 0 # to know where to start the indexing for each string\n        for i in range(len(spaces)):\n            final_list.append(s[prev_index:spaces[i]]) # adds all the letters from the prev_index to the current index\n            prev_index = spaces[i] # update the prev_index to new index\n            # print(final_list)  \n        final_list.append(s[prev_index:])\n        return \" \".join(final_list)",
        "detail": "Normal Problems.2109 - Adding Spaces to a String",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.2125 - Number of Laser Beams in a Bank",
        "description": "Normal Problems.2125 - Number of Laser Beams in a Bank",
        "peekOfCode": "class Solution:\n    def numberOfBeams(self, bank: List[str]) -> int:\n        prev, ans = 0, 0\n        for s in bank:\n            count = 0\n            for char in s:\n                if char == '1':\n                    count += 1\n            if count != 0:\n                ans += prev * count",
        "detail": "Normal Problems.2125 - Number of Laser Beams in a Bank",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.217 - Contains Duplicate",
        "description": "Normal Problems.217 - Contains Duplicate",
        "peekOfCode": "class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool: # type:ignore\n        hashmap = defaultdict(int)\n        for n in nums:\n            hashmap[n] += 1\n        for count in hashmap.values():\n            if count > 1:\n                return True\n        return False\n# -------------------------------------",
        "detail": "Normal Problems.217 - Contains Duplicate",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.217 - Contains Duplicate",
        "description": "Normal Problems.217 - Contains Duplicate",
        "peekOfCode": "class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool: #type:ignore\n        seen = set()\n        for num in nums:\n            if num in seen:\n                return True\n            seen.add(num)\n        return False",
        "detail": "Normal Problems.217 - Contains Duplicate",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.2177 - Find Three Consecutive Integers That Sum to a Given Number",
        "description": "Normal Problems.2177 - Find Three Consecutive Integers That Sum to a Given Number",
        "peekOfCode": "class Solution(object):\n    def sumOfThree(self, num: int) -> List[int]: #type:ignore\n        if num % 3 == 0:\n            num //= 3\n            return [num - 1, num, num + 1]\n        return []",
        "detail": "Normal Problems.2177 - Find Three Consecutive Integers That Sum to a Given Number",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.2180 - Count Integers With Even Digit Sum",
        "description": "Normal Problems.2180 - Count Integers With Even Digit Sum",
        "peekOfCode": "class Solution:\n    def countEven(self, num: int) -> int:\n        # initiate count to 0\n        count = 0\n        # iterate through all the number from 2 to num\n        for num in range(2, num+1):\n            cur_sum = 0\n            cur_num = num\n            while cur_num != 0:\n                rem = cur_num % 10",
        "detail": "Normal Problems.2180 - Count Integers With Even Digit Sum",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.2185 - Counting Words With a Given Prefix",
        "description": "Normal Problems.2185 - Counting Words With a Given Prefix",
        "peekOfCode": "class Solution:\n    def prefixCount(self, words: List[str], pref: str) -> int: #type:ignore\n        # set prefix length to iterate the word\n        prefix_len = len(pref)\n        counter = 0 \n        for i in range(len(words)):\n            if pref == words[i][:prefix_len]:\n                counter += 1\n        return counter",
        "detail": "Normal Problems.2185 - Counting Words With a Given Prefix",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.2225 - Find Players With Zero or One Losses",
        "description": "Normal Problems.2225 - Find Players With Zero or One Losses",
        "peekOfCode": "class Solution:\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\n        losses = defaultdict(int)\n        played_matches = set()\n        for winner, loser in matches:\n            losses[loser] += 1\n            played_matches.add(winner)\n            played_matches.add(loser)\n        winners = [player for player in played_matches if losses[player] == 0]\n        one_loss_players = [player for player in played_matches if losses[player] == 1]",
        "detail": "Normal Problems.2225 - Find Players With Zero or One Losses",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.2240 - Number of Ways to Buy Pens and Pencils",
        "description": "Normal Problems.2240 - Number of Ways to Buy Pens and Pencils",
        "peekOfCode": "class Solution:\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\n        l = cost1 if cost1 > cost2 else cost2\n        s = cost2 if l == cost1 else cost1\n        res = 0\n        maxl = total // l\n        for n in range(maxl + 1):\n            res += (total - n * l) // s + 1\n        return res",
        "detail": "Normal Problems.2240 - Number of Ways to Buy Pens and Pencils",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.2255 - Count Prefixes of a Given String",
        "description": "Normal Problems.2255 - Count Prefixes of a Given String",
        "peekOfCode": "class Solution:\n    def countPrefixes(self, words: List[str], s: str) -> int: # type: ignore\n        counter = 0\n        for prefix in words:\n            # get the len of every prefix because their lengths differ\n            lenPrefix = len(prefix)\n            if prefix == s[:lenPrefix]:\n                counter += 1\n        return counter",
        "detail": "Normal Problems.2255 - Count Prefixes of a Given String",
        "documentation": {}
    },
    {
        "label": "MyQueue",
        "kind": 6,
        "importPath": "Normal Problems.232 - Implement Queue using Stacks",
        "description": "Normal Problems.232 - Implement Queue using Stacks",
        "peekOfCode": "class MyQueue:\n    def __init__(self):\n        self.s1 = []\n        self.s2 = []\n    def push(self, x):\n        if not self.s1:\n            self.front = x\n        while self.s1:\n            self.s2.append(self.s1.pop())\n        self.s2.append(x)",
        "detail": "Normal Problems.232 - Implement Queue using Stacks",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.2364 - Count Number of Bad Pairs",
        "description": "Normal Problems.2364 - Count Number of Bad Pairs",
        "peekOfCode": "class Solution:\n    def countBadPairs(self, nums: List[int]) -> int: #type:ignore\n        bad_pairs = 0\n        diff_count = {}\n        for pos in range(len(nums)):\n            diff = pos - nums[pos]\n            # Count of previous positions with same difference\n            good_pairs_count = diff_count.get(diff, 0)\n            # Total possible pairs minus good pairs = bad pairs\n            bad_pairs += pos - good_pairs_count",
        "detail": "Normal Problems.2364 - Count Number of Bad Pairs",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.2385 - Amount of Time for Binary Tree to Be Infected",
        "description": "Normal Problems.2385 - Amount of Time for Binary Tree to Be Infected",
        "peekOfCode": "class Solution:\n    def __init__(self):\n        self.max_distance = 0\n    def amountOfTime(self, root, start):\n        self.traverse(root, start)\n        return self.max_distance\n    def traverse(self, root, start):\n        depth = 0\n        if root is None:\n            return depth",
        "detail": "Normal Problems.2385 - Amount of Time for Binary Tree to Be Infected",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.258 - Add Digits",
        "description": "Normal Problems.258 - Add Digits",
        "peekOfCode": "class Solution:\n    def addDigits(self, num: int) -> int:\n        while len(str(num)) > 1:\n            num_list = [int(digit) for digit in str(num)]\n            num = sum(num_list)\n        return num\n############################# Another way ###################################################\nclass Solution:\n    def addDigits(self, num: int) -> int:\n        while num >= 10:  ",
        "detail": "Normal Problems.258 - Add Digits",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.258 - Add Digits",
        "description": "Normal Problems.258 - Add Digits",
        "peekOfCode": "class Solution:\n    def addDigits(self, num: int) -> int:\n        while num >= 10:  \n            num = sum(int(digit) for digit in str(num))  \n        return num\n########################### Another smart one ############################################\nclass Solution:\n    def addDigits(self, num: int) -> int:\n        if num == 0:\n            return 0",
        "detail": "Normal Problems.258 - Add Digits",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.258 - Add Digits",
        "description": "Normal Problems.258 - Add Digits",
        "peekOfCode": "class Solution:\n    def addDigits(self, num: int) -> int:\n        if num == 0:\n            return 0\n        return 1 + (num - 1) % 9",
        "detail": "Normal Problems.258 - Add Digits",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.26 - Remove Duplicates from Sorted Array",
        "description": "Normal Problems.26 - Remove Duplicates from Sorted Array",
        "peekOfCode": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int: #type:ignore\n        if not nums:\n            return 0\n        i = 0\n        while i < len(nums) - 1:\n            if nums[i] == nums[i + 1]:\n                nums.pop(i + 1)\n            else:\n                i += 1",
        "detail": "Normal Problems.26 - Remove Duplicates from Sorted Array",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.2610 - Convert an Array Into a 2D Array With Conditions",
        "description": "Normal Problems.2610 - Convert an Array Into a 2D Array With Conditions",
        "peekOfCode": "class Solution:\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\n        # freq should be a list of size nums + 1\n        freq = [0] * (len(nums) + 1)\n        ans = []\n        for c in nums:\n            if freq[c] >= len(ans):\n                ans.append([])\n            ans[freq[c]].append(c)\n            freq[c] += 1",
        "detail": "Normal Problems.2610 - Convert an Array Into a 2D Array With Conditions",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.27 - Remove Element",
        "description": "Normal Problems.27 - Remove Element",
        "peekOfCode": "class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int: #type:ignore\n        i = 0\n        while i < len(nums):\n            if nums[i] == val:\n                nums.pop(i)\n            else:\n                i += 1\n        return len(nums)\n###################################### Another Solution ############################################",
        "detail": "Normal Problems.27 - Remove Element",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.2706 - Buy Two Chocolates",
        "description": "Normal Problems.2706 - Buy Two Chocolates",
        "peekOfCode": "class Solution:\n    def buyChoco(self, prices: List[int], money: int) -> int:\n        def merge_sort(arr):\n            if len(arr) <= 1:\n                return arr\n            mid = len(arr) // 2\n            l_half = arr[:mid]\n            r_half = arr[mid:]\n            l_half = merge_sort(l_half)\n            r_half = merge_sort(r_half)",
        "detail": "Normal Problems.2706 - Buy Two Chocolates",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.278 - First Bad Version",
        "description": "Normal Problems.278 - First Bad Version",
        "peekOfCode": "class Solution:\n    def firstBadVersion(self, n: int) -> int:\n        left = 0\n        right = n\n        while left < right:\n            mid = (left + right) // 2\n            if isBadVersion(mid): # type: ignore\n                right = mid\n            else:\n                left = mid + 1",
        "detail": "Normal Problems.278 - First Bad Version",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.28 - Find the Index of the First Occurrence in a String",
        "description": "Normal Problems.28 - Find the Index of the First Occurrence in a String",
        "peekOfCode": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        if needle == \"\":\n            return 0\n        for i in range(len(haystack) + 1 - len(needle)):\n            if haystack[i: i + len(needle)] == needle:\n                return i",
        "detail": "Normal Problems.28 - Find the Index of the First Occurrence in a String",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.283 - Move Zeroes",
        "description": "Normal Problems.283 - Move Zeroes",
        "peekOfCode": "class Solution:\n    def moveZeroes(self, nums: List[int]) -> None: #type:ignore\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        left = 0\n        for right in range(len(nums)):\n            if nums[right] != 0:\n                # swap right and left elements\n                nums[left], nums[right] = nums[right], nums[left]",
        "detail": "Normal Problems.283 - Move Zeroes",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.2870 - Minimum Number of Operations to Make Array Empty",
        "description": "Normal Problems.2870 - Minimum Number of Operations to Make Array Empty",
        "peekOfCode": "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        counter = Counter(nums)\n        ans = 0\n        for num in counter.values():\n            if num == 1:\n                return -1\n            ans += ceil(num / 3)\n        return ans",
        "detail": "Normal Problems.2870 - Minimum Number of Operations to Make Array Empty",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.2957 - Remove Adjacent Almost-Equal Characters",
        "description": "Normal Problems.2957 - Remove Adjacent Almost-Equal Characters",
        "peekOfCode": "class Solution:\n    def removeAlmostEqualCharacters(self, s: str) -> int:\n        ans = 0\n        n = len(s)\n        i = 1\n        while i < n:\n            if abs(ord(s[i]) - ord(s[i - 1])) == 1 or s[i] == s[i - 1]:\n                ans += 1\n                i += 2\n                continue",
        "detail": "Normal Problems.2957 - Remove Adjacent Almost-Equal Characters",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.2981 - Find Longest Special Substring That Occurs Thrice I",
        "description": "Normal Problems.2981 - Find Longest Special Substring That Occurs Thrice I",
        "peekOfCode": "class Solution:\n    def maximumLength(self, s: str) -> int:\n        n = len(s)\n        l, r = 1, n\n        if not self.helper(s, n, l):\n            return -1\n        while l + 1 < r:\n            mid = (l + r) // 2\n            if self.helper(s, n, mid):\n                l = mid",
        "detail": "Normal Problems.2981 - Find Longest Special Substring That Occurs Thrice I",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.3105 - Longest Strictly Increasing or Strictly Decreasing Subarray",
        "description": "Normal Problems.3105 - Longest Strictly Increasing or Strictly Decreasing Subarray",
        "peekOfCode": "class Solution:\n    def longestMonotonicSubarray(self, nums: List[int]) -> int: # type: ignore\n        maxi = 1\n        current_streak = 1\n        back_streak = 1\n        for i in range(len(nums) - 1):\n            if nums[i] < nums[i + 1]:\n                current_streak += 1\n                if maxi < current_streak:\n                    maxi = current_streak",
        "detail": "Normal Problems.3105 - Longest Strictly Increasing or Strictly Decreasing Subarray",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.3152 - Special Array II",
        "description": "Normal Problems.3152 - Special Array II",
        "peekOfCode": "class Solution:\n    def isArraySpecial(self, nums: List[int], queries: List[List[int]]) -> List[bool]: #type:ignore\n        n = len(nums)\n        prefix = [0] * n  # Prefix array to count special pairs\n        result = []  # Result list\n        # Build the prefix array\n        for i in range(1, n):\n            prefix[i] = prefix[i - 1]\n            if (nums[i - 1] % 2 == 0 and nums[i] % 2 == 0) or (nums[i - 1] % 2 != 0 and nums[i] % 2 != 0):\n                prefix[i] += 1",
        "detail": "Normal Problems.3152 - Special Array II",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.3160 - Find the Number of Distinct Colors Among the Balls",
        "description": "Normal Problems.3160 - Find the Number of Distinct Colors Among the Balls",
        "peekOfCode": "class Solution:\n    def queryResults(self, limit: int, queries: List[List[int]]) -> List[int]:\n        n=len(queries)\n        ans=[0]*n\n        mp={}\n        color=defaultdict(int)\n        i=0\n        for x, c in queries:\n            if x in mp:\n                c0=mp[x]",
        "detail": "Normal Problems.3160 - Find the Number of Distinct Colors Among the Balls",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.33 - Search in Rotated Sorted Array",
        "description": "Normal Problems.33 - Search in Rotated Sorted Array",
        "peekOfCode": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        # Declaring variables\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2 \n            if target == nums[mid]:\n                return mid\n            if nums[left] <= nums[mid]:\n                if target >= nums[left] and target < nums[mid]:",
        "detail": "Normal Problems.33 - Search in Rotated Sorted Array",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.34 - Find First and Last Position of Element in Sorted Array",
        "description": "Normal Problems.34 - Find First and Last Position of Element in Sorted Array",
        "peekOfCode": "class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        def binary_search_left(nums, target):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = left + (right - left) // 2\n                if nums[mid] == target:\n                    right = mid - 1\n                elif nums[mid] < target:\n                    left = mid + 1",
        "detail": "Normal Problems.34 - Find First and Last Position of Element in Sorted Array",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.347 - Top K Frequent Elements",
        "description": "Normal Problems.347 - Top K Frequent Elements",
        "peekOfCode": "class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]: #type:ignore\n        hashmap = defaultdict(int)\n        result = []\n        for num in nums:\n            hashmap[num] += 1\n        for i in range(k):\n            max_key = max(hashmap, key=hashmap.get)  \n            result.append(max_key)                \n            del hashmap[max_key]  ",
        "detail": "Normal Problems.347 - Top K Frequent Elements",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.35 - Search Insert Position",
        "description": "Normal Problems.35 - Search Insert Position",
        "peekOfCode": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        upper_bound, lower_bound = len(nums) - 1, 0\n        while lower_bound <= upper_bound:\n            index = (upper_bound + lower_bound) // 2\n            if target == nums[index]:\n                return index \n            elif target > nums[index]:\n                lower_bound = index + 1\n            else:",
        "detail": "Normal Problems.35 - Search Insert Position",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.367 - Valid Perfect Square",
        "description": "Normal Problems.367 - Valid Perfect Square",
        "peekOfCode": "class Solution:\n    #Declaring function\n    def isPerfectSquare(self, num: int) -> bool:\n        # To make sure the number is greater than 0\n        if num < 0:\n            return False\n        # Assinging Variables\n        left, right = 0, num\n        # Start of loop\n        while left <= right:",
        "detail": "Normal Problems.367 - Valid Perfect Square",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.374 - Guess Number Higher or Lower",
        "description": "Normal Problems.374 - Guess Number Higher or Lower",
        "peekOfCode": "class Solution:\n    def guessNumber(self, n: int) -> int:\n        right, left = n, 0\n        while left <= right:\n            mid = (left + right) // 2\n            if guess(mid) == 0:\n                return mid\n            elif guess(mid) == 1:\n                left = mid + 1\n            else:",
        "detail": "Normal Problems.374 - Guess Number Higher or Lower",
        "documentation": {}
    },
    {
        "label": "RandomizedSet",
        "kind": 6,
        "importPath": "Normal Problems.380 - Insert Delete GetRandom O(1)",
        "description": "Normal Problems.380 - Insert Delete GetRandom O(1)",
        "peekOfCode": "class RandomizedSet:\n    def __init__(self):\n        self.val_to_index = {}\n        self.values = []\n    def insert(self, val: int) -> bool:\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True",
        "detail": "Normal Problems.380 - Insert Delete GetRandom O(1)",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.413 - Arithmetic Slices",
        "description": "Normal Problems.413 - Arithmetic Slices",
        "peekOfCode": "class Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        if len(nums) < 3:\n            return 0\n        sol = 0\n        for i in range(len(nums)):#starting index of subarray\n            for j in range(i + 1, len(nums)-1):\n                if nums[j] - nums[j-1] != nums[j+1] - nums[j]:\n                    break\n                else:",
        "detail": "Normal Problems.413 - Arithmetic Slices",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.446 - Arithmetic Slices II - Subsequence",
        "description": "Normal Problems.446 - Arithmetic Slices II - Subsequence",
        "peekOfCode": "class Solution:\n    def numberOfArithmeticSlices(self, nums):\n        n = len(nums)\n        count = 0\n        dp = [{} for _ in range(n)] \n        for i in range(n):\n            for j in range(i):\n                diff = nums[i] - nums[j]\n                if diff in dp[j]:\n                    dp[i][diff] = dp[i].get(diff, 0) + dp[j][diff]",
        "detail": "Normal Problems.446 - Arithmetic Slices II - Subsequence",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.476 - Number Complement",
        "description": "Normal Problems.476 - Number Complement",
        "peekOfCode": "class Solution:\n    def findComplement(self, num: int) -> int:\n        binary_num = bin(num)[2:]  # convert the number into its binary form and slice off the '0b'\n        complimented_num = [] # compliment the number\n        for bit in binary_num:\n            if bit == '1':\n                complimented_num.append('0')\n            else:\n                complimented_num.append('1')\n        # Convert the complemented binary string back to an integer",
        "detail": "Normal Problems.476 - Number Complement",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.485 - Max Consecutive Ones",
        "description": "Normal Problems.485 - Max Consecutive Ones",
        "peekOfCode": "class Solution:\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int: #type:ignore\n        max_consecutive_ones = 0\n        current_consecutive_ones = 0\n        for num in nums:\n            if num == 1:\n                current_consecutive_ones += 1\n                max_consecutive_ones = max(max_consecutive_ones, current_consecutive_ones)\n            else:\n                current_consecutive_ones = 0",
        "detail": "Normal Problems.485 - Max Consecutive Ones",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.496 - Next Greater Element I",
        "description": "Normal Problems.496 - Next Greater Element I",
        "peekOfCode": "class Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        ans=defaultdict(lambda : 0)\n        stack=[]\n        n = len(nums2)\n        for i in reversed(range(n)):\n            while(stack and nums2[i]>stack[-1]):\n                stack.pop(-1)\n            if stack:\n                ans[nums2[i]] = stack[-1]",
        "detail": "Normal Problems.496 - Next Greater Element I",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "Normal Problems.590 - N-ary Tree Postorder Traversal",
        "description": "Normal Problems.590 - N-ary Tree Postorder Traversal",
        "peekOfCode": "class Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\"\"\"\nclass Solution:\n    def postorder(self, root: 'Node') -> List[int]: # type:ignore\n        if not root:\n            return []\n        stack, result = [root], []",
        "detail": "Normal Problems.590 - N-ary Tree Postorder Traversal",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.590 - N-ary Tree Postorder Traversal",
        "description": "Normal Problems.590 - N-ary Tree Postorder Traversal",
        "peekOfCode": "class Solution:\n    def postorder(self, root: 'Node') -> List[int]: # type:ignore\n        if not root:\n            return []\n        stack, result = [root], []\n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            stack.extend(node.children) \n        return result[::-1]",
        "detail": "Normal Problems.590 - N-ary Tree Postorder Traversal",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.592 - Fraction Addition and Subtraction",
        "description": "Normal Problems.592 - Fraction Addition and Subtraction",
        "peekOfCode": "class Solution:\n    def fractionAddition(self, expression: str) -> str:\n        expression = expression.replace('-', '+-')\n        fractions = expression.split('+')\n        result = Fraction(0, 1)\n        for fraction in fractions:\n            if fraction:\n                result += Fraction(fraction)\n        return f\"{result.numerator}/{result.denominator}\"",
        "detail": "Normal Problems.592 - Fraction Addition and Subtraction",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.633 - Sum of Square Numbers",
        "description": "Normal Problems.633 - Sum of Square Numbers",
        "peekOfCode": "class Solution:\n    def judgeSquareSum(self, c: int) -> bool:\n        a, b = 0, int(math.sqrt(c))\n        left, right = a, b\n        while left <= right:\n            current_sum = left**2 + right**2\n            if current_sum == c:\n                return True\n            elif current_sum > c:\n                right -= 1",
        "detail": "Normal Problems.633 - Sum of Square Numbers",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.658 - Find K Closest Elements",
        "description": "Normal Problems.658 - Find K Closest Elements",
        "peekOfCode": "class Solution:\n    def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]: #type:ignore\n        l, r = 0, len(arr) - k\n        while l < r:\n            m = (l + r) // 2\n            if x - arr[m] > arr[m + k] - x:\n                l = m + 1\n            else:\n                r = m\n        return arr[l:l+k]",
        "detail": "Normal Problems.658 - Find K Closest Elements",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.66 - Plus One",
        "description": "Normal Problems.66 - Plus One",
        "peekOfCode": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]: # type: ignore\n        for i in range(len(digits) - 1, -1, -1):\n            if digits[i] + 1 != 10:\n                digits[i] += 1\n                return digits\n            digits[i] = 0\n            if i == 0:\n                return [1] + digits",
        "detail": "Normal Problems.66 - Plus One",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.682 - Baseball Game",
        "description": "Normal Problems.682 - Baseball Game",
        "peekOfCode": "class Solution:\n    def calPoints(self, operations: List[str]) -> int: # type: ignore\n        stack = []\n        for op in operations:\n            if op == '+':\n                stack.append(int(stack[-2]) + int(stack[-1]))\n            elif op == 'D':\n                stack.append(int(stack[-1])*2)\n            elif op == 'C':\n                stack.pop()",
        "detail": "Normal Problems.682 - Baseball Game",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.69 - Sqrt(x)",
        "description": "Normal Problems.69 - Sqrt(x)",
        "peekOfCode": "class Solution:\n    def mySqrt(self, x: int) -> int:\n        if x < 0:\n            return False\n        left, right = 0, x\n        while left <= right:\n            mid = (left + right) // 2\n            squared = mid * mid\n            if squared == x:\n                return mid",
        "detail": "Normal Problems.69 - Sqrt(x)",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.70 - Climbing Stairs",
        "description": "Normal Problems.70 - Climbing Stairs",
        "peekOfCode": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        ways = [0] * (n + 1)\n        ways[1] = 1\n        ways[2] = 2\n        for i in range(3, n + 1):",
        "detail": "Normal Problems.70 - Climbing Stairs",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.704 - Binary Search",
        "description": "Normal Problems.704 - Binary Search",
        "peekOfCode": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                right = mid - 1\n            else:",
        "detail": "Normal Problems.704 - Binary Search",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.71 - Simplify Path",
        "description": "Normal Problems.71 - Simplify Path",
        "peekOfCode": "class Solution:\n    def simplifyPath(self, path: str) -> str:\n        parts = path.split('/')\n        stack = []\n        for part in parts:\n            if part == '..':\n                if stack:\n                    stack.pop()\n            elif part and part != '.':\n                stack.append(part)",
        "detail": "Normal Problems.71 - Simplify Path",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.744 - Find Smallest Letter Greater Than Target",
        "description": "Normal Problems.744 - Find Smallest Letter Greater Than Target",
        "peekOfCode": "class Solution:\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str: #type: ignore\n        left, right = 0, len(letters) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if letters[mid] <= target:\n                left = mid + 1 \n            else:\n                right = mid - 1\n        return letters[left % len(letters)]",
        "detail": "Normal Problems.744 - Find Smallest Letter Greater Than Target",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.844 - Backspace String Compare",
        "description": "Normal Problems.844 - Backspace String Compare",
        "peekOfCode": "class Solution:\n    def backspaceCompare(self, s: str, t: str) -> bool:\n        stack_s = []\n        stack_t = []\n        for char in s:\n            if char == '#':\n                if stack_s:\n                    stack_s.pop()\n            else:\n                stack_s.append(char)",
        "detail": "Normal Problems.844 - Backspace String Compare",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.844 - Backspace String Compare",
        "description": "Normal Problems.844 - Backspace String Compare",
        "peekOfCode": "class Solution:\n    def backspaceCompare(self, s: str, t: str) -> bool:\n        def pro(s):\n            k = []\n            for c in s:\n                if c == '#':\n                    if k:\n                        k.pop()\n                else:\n                    k.append(c)",
        "detail": "Normal Problems.844 - Backspace String Compare",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.856 - Score of Parentheses",
        "description": "Normal Problems.856 - Score of Parentheses",
        "peekOfCode": "class Solution:\n    def scoreOfParentheses(self, s: str) -> int:\n        stack = [0]\n        total = 0\n        for ch in s:\n            if ch == \"(\":\n                stack.append(0)\n            else:\n                top = stack.pop()\n                val = max(1, 2 * top)",
        "detail": "Normal Problems.856 - Score of Parentheses",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "Normal Problems.872 - Leaf-Similar Trees",
        "description": "Normal Problems.872 - Leaf-Similar Trees",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution:\n    def leafSimilar(self, root1, root2):\n        def get_leaves_sequence(root):\n            leaves = []\n            stack = [root]",
        "detail": "Normal Problems.872 - Leaf-Similar Trees",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.872 - Leaf-Similar Trees",
        "description": "Normal Problems.872 - Leaf-Similar Trees",
        "peekOfCode": "class Solution:\n    def leafSimilar(self, root1, root2):\n        def get_leaves_sequence(root):\n            leaves = []\n            stack = [root]\n            while stack:\n                node = stack.pop()\n                if not node.left and not node.right:\n                    leaves.append(node.val)\n                if node.right:",
        "detail": "Normal Problems.872 - Leaf-Similar Trees",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.88 - Merge Sorted Array",
        "description": "Normal Problems.88 - Merge Sorted Array",
        "peekOfCode": "class Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None: # type:ignore\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        # last index in nums1:\n        last = m + n - 1\n        while m > 0 and n > 0:\n            if nums1[m - 1] > nums2[n - 1]:\n                nums1[last] = nums1[m - 1]",
        "detail": "Normal Problems.88 - Merge Sorted Array",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.907 - Sum of Subarray Minimums",
        "description": "Normal Problems.907 - Sum of Subarray Minimums",
        "peekOfCode": "class Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        MOD = 10**9 + 7\n        result = 0\n        stack = []\n        arr.append(0)  # Append a sentinel element to handle the last few elements in the array\n        for i, num in enumerate(arr):\n            while stack and arr[stack[-1]] > num:\n                idx = stack.pop()\n                result += arr[idx] * (i - idx) * (idx - stack[-1] if stack else idx + 1)",
        "detail": "Normal Problems.907 - Sum of Subarray Minimums",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.931 - Minimum Falling Path Sum",
        "description": "Normal Problems.931 - Minimum Falling Path Sum",
        "peekOfCode": "class Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        rows, cols = len(matrix), len(matrix[0])\n        for row in range(1, rows):\n            for col in range(cols):\n                matrix[row][col] += min(\n                    matrix[row - 1][max(col - 1, 0):col + 2]\n                )\n        return min(matrix[-1])",
        "detail": "Normal Problems.931 - Minimum Falling Path Sum",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "Normal Problems.938 - Range Sum of BST",
        "description": "Normal Problems.938 - Range Sum of BST",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution:\n    def rangeSumBST(self, root, low, high):\n        if not root:\n            return 0\n        sum_val = 0",
        "detail": "Normal Problems.938 - Range Sum of BST",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Normal Problems.938 - Range Sum of BST",
        "description": "Normal Problems.938 - Range Sum of BST",
        "peekOfCode": "class Solution:\n    def rangeSumBST(self, root, low, high):\n        if not root:\n            return 0\n        sum_val = 0\n        if low <= root.val <= high:\n            sum_val += root.val\n        if root.val > low:\n            sum_val += self.rangeSumBST(root.left, low, high)\n        if root.val < high:",
        "detail": "Normal Problems.938 - Range Sum of BST",
        "documentation": {}
    }
]